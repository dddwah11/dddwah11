{"meta":{"title":"61分","subtitle":"","description":"","author":"小刘","url":"https://dddwah11.github.io","root":"/"},"pages":[],"posts":[{"title":"vue3","slug":"4-26/vue2","date":"2022-04-26T10:44:31.729Z","updated":"2022-04-28T09:33:44.095Z","comments":true,"path":"2022/04/26/4-26/vue2/","link":"","permalink":"https://dddwah11.github.io/2022/04/26/4-26/vue2/","excerpt":"","text":"vue cli脚手架npm install -g @vue/cli 创建一个vue项目vue create project-name 项目结构main.jsimport &#123; createApp &#125; from &#39;vue&#39; import App from &#39;./App.vue&#39; // 根组件 createApp(App).mount(&#39;#app&#39;) main.js 会创建我们vue的实例，挂载会帮我们创建根组件的实例vm APP.vue&lt;template&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt; &lt;/template&gt; &lt;script&gt; import HelloWorld from &#39;./components/HelloWorld.vue&#39; export default &#123; name: &#39;App&#39;, components: &#123; HelloWorld &#125; &#125; &lt;/script&gt; &lt;style&gt; #app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; &#125; &lt;/style&gt; webpackViteVite 是一个 web 开发构建工具，由于其原生 ES 模块导入方式，可以实现闪电般的冷服务器启动。 通过在终端中运行以下命令，可以使用 Vite 快速构建 Vue 项目。 使用 npm： # npm 6.x $ npm init vite@latest &lt;project-name&gt; --template vue # npm 7+，需要加上额外的双短横线 $ npm init vite@latest &lt;project-name&gt; -- --template vue $ cd &lt;project-name&gt; $ npm install $ npm run serve/dev 安装依赖 npm install 安装vue-router npm install vue-router@4 安装element-ui npm install --legacy-peer-deps element-ui --save 安装 SASS 加载器 cnpm install sass-loader node-sass --save-dev 启动测试 npm run serve/dev 创建modules目录 在文件目录下 运行 webpack 创建index.html并引入 &lt;script src =&quot;dist/js/bundle.js&quot;&gt;&lt;/script&gt; axiosnpm add axois import axios from &#39;axios&#39;; mounted()&#123; getData()&#123; axios.get(&quot;xxx&quot;).then(res =&gt;&#123; &#125;) &#125; vue_router安装vue-router到项目目录 npm install vue-router@4 -s/安装在本地项目，在packge.json中 使用cdn &lt;script src=&quot;https://unpkg.com/vue@3&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router@4&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- use the router-link component for navigation. --&gt; &lt;!-- specify the link by passing the `to` prop. --&gt; &lt;!-- `&lt;router-link&gt;` will render an `&lt;a&gt;` tag with the correct `href` attribute --&gt; &lt;router-link to=&quot;/&quot;&gt;Go to Home&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;Go to About&lt;/router-link&gt; &lt;/p&gt; &lt;!-- route outlet --&gt; &lt;!-- component matched by the route will render here --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; 报错 error Component name “About” should always be multi-word vue&#x2F;multi-word-component-names 在vue.config.js文件中添加 const &#123; defineConfig &#125; = require(&#39;@vue/cli-service&#39;) module.exports = defineConfig(&#123; transpileDependencies: true, lintOnSave:false &#125;) 在Vue脚手架当中 main.js中 import &#123; createApp &#125; from &#39;vue&#39; import App from &#39;./App.vue&#39; import &#123; createRouter, createWebHashHistory&#125; from &#39;vue-router&#39; //从vue-router中解构 花括号中的两个方法 import Hhome from &#39;./components/Hhome.vue&#39; import Ahbout from &#39;./components/Ahbout.vue&#39; // 2. 定义一些路由 // 每个路由都需要映射到一个组件。 // 我们后面再讨论嵌套路由。 const routes = [ &#123; path: &#39;/&#39;, component: Hhome &#125;, &#123; path: &#39;/about&#39;, component: Ahbout &#125;, ] // 3. 创建路由实例并传递 `routes` 配置 // 你可以在这里输入更多的配置，但我们在这里 // 暂时保持简单 const router = createRouter(&#123; // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。 history: createWebHashHistory(), routes, // `routes: routes` 的缩写 &#125;) // 根组件 let app = createApp(App).use(router); app.mount(&#39;#app&#39;) APP.vue中 &lt;template&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- use the router-link component for navigation. --&gt; &lt;!-- specify the link by passing the `to` prop. --&gt; &lt;!-- `&lt;router-link&gt;` will render an `&lt;a&gt;` tag with the correct `href` attribute --&gt; &lt;router-link to=&quot;/&quot;&gt;Go to Home&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;Go to About&lt;/router-link&gt; &lt;/p&gt; &lt;!-- route outlet --&gt; &lt;!-- component matched by the route will render here --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/template&gt; &lt;script&gt; import home from &quot;./components/Hhome.vue&quot;; import about from &quot;./components/Ahbout.vue&quot;; export default &#123; name: &quot;App&quot;, components: &#123; home, about &#125;, &#125;; &lt;/script&gt; &lt;style&gt; #app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; &#125; &lt;/style&gt; 代码改造 解决路由过多 新建router目录，在其下新建index.js改造代码 //完成路由相关的工作 import &#123; createRouter, createWebHashHistory&#125; from &#39;vue-router&#39; //从vue-router中解构 花括号中的两个方法 import Hhome from &#39;../components/Hhome.vue&#39; import Ahbout from &#39;../components/Ahbout.vue&#39; // 2. 定义一些路由 // 每个路由都需要映射到一个组件。 // 我们后面再讨论嵌套路由。 const routes = [ &#123; path: &#39;/&#39;, component: Hhome &#125;, &#123; path: &#39;/about&#39;, component: Ahbout &#125;, ] // 3. 创建路由实例并传递 `routes` 配置 // 你可以在这里输入更多的配置，但我们在这里 // 暂时保持简单 const router = createRouter(&#123; // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。 history: createWebHashHistory(), routes, // `routes: routes` 的缩写 &#125;) //暴露一个router方法给main.js export default router main.js中 import &#123; createApp &#125; from &#39;vue&#39; import App from &#39;./App.vue&#39; import router from &#39;./router&#39; // 根组件 let app = createApp(App).use(router); app.mount(&#39;#app&#39;) 这样分工就十分明确了！ 动态路由匹配router下的index.js &#123;path: &#39;/user/:id&#39;, component: use&#125; 通过组件传参 &lt;div&gt;my id is &#123;&#123;$router.params.id&#125;&#125;&lt;/div&gt; 总组件中 &lt;template&gt; &lt;router-link to=&quot;/user/13&quot;&gt;13&lt;/router-link&gt; | &lt;router-link to=&quot;/user/12&quot;&gt;12&lt;/router-link&gt; | &lt;/template&gt; 一些语法通过自定义的正则： path: &#39;/user/:id(//d+)&#39; （&#x2F;&#x2F;d+）表示传入的参数只能是数字 可重复的参数 path: &#39;/user/:id(//d+)*&#39; 在其后面加*符号，这提供了一个参数数组，而不是字符串 可选的参数 在id后面加？ 可与可无 嵌套路由在user.vue组件中嵌套两个组件 user.vue中 &lt;template&gt; &lt;div&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt; my id is &#123;&#123;$router.params.id&#125;&#125; &lt;/p&gt; &lt;router-link v-bind:to=&quot;&#39;/user/&#39;+$router.params.id+&#39;/profile&#39;&quot;&gt;头像&lt;/router-link&gt; &lt;router-link v-bind:to=&quot;&#39;/user/&#39;+$router.params.id+&#39;/posts&#39;&quot;&gt;岗位&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; router中的index.js中 &#123; path: &#39;/user/:id&#39;, component: user, children: [ &#123; // UserProfile will be rendered inside User&#39;s &lt;router-view&gt; // when /user/:id/profile is matched path: &#39;profile&#39;, component: UserProfile, &#125;, &#123; // UserPosts will be rendered inside User&#39;s &lt;router-view&gt; // when /user/:id/posts is matched path: &#39;posts&#39;, component: UserPosts, &#125;, ] &#125; 命名路线除了path，您还可以提供name任何路线。这具有以下优点： 没有硬编码的 URL 自动编码&#x2F;解码params 防止您在网址中出现拼写错误 绕过路径排名（例如显示 a ） const routes = [ &#123; path: &#39;/user/:username&#39;, name: &#39;user&#39;, component: User &#125; ] 要链接到命名路由，您可以将对象传递给router-link组件的toprop： &lt;router-link :to=&quot;&#123; name: &#39;user&#39;, params: &#123; username: &#39;erina&#39; &#125;&#125;&quot;&gt; User &lt;/router-link&gt; 命名视图有时您需要同时显示多个视图而不是嵌套它们，例如创建一个带有sidebar视图和main视图的布局。这就是命名视图派上用场的地方。您可以拥有多个并为每个插座命名，而不是在您的视图中只有一个插座。没有名字的 Arouter-view将default作为它的名字。 &lt;router-view class=&quot;view left-sidebar&quot; name=&quot;LeftSidebar&quot;&gt;&lt;/router-view&gt; &lt;router-view class=&quot;view main-content&quot;&gt;&lt;/router-view&gt; &lt;router-view class=&quot;view right-sidebar&quot; name=&quot;RightSidebar&quot;&gt;&lt;/router-view&gt; 一个视图是使用一个组件来渲染的，因此多个视图需要多个组件用于同一条路线。确保使用components（带有s）选项： const router = createRouter(&#123; history: createWebHashHistory(), routes: [ &#123; path: &#39;/&#39;, components: &#123; default: Home, // short for LeftSidebar: LeftSidebar LeftSidebar, // they match the `name` attribute on `&lt;router-view&gt;` RightSidebar, &#125;, &#125;, ], &#125;) 嵌套命名视图可以使用带有嵌套视图的命名视图来创建复杂的布局。这样做时，您还需要为嵌套router-view命名。让我们以设置面板为例： /settings/emails /settings/profile +-----------------------------------+ +------------------------------+ | UserSettings | | UserSettings | | +-----+-------------------------+ | | +-----+--------------------+ | | | Nav | UserEmailsSubscriptions | | +------------&gt; | | Nav | UserProfile | | | | +-------------------------+ | | | +--------------------+ | | | | | | | | | UserProfilePreview | | | +-----+-------------------------+ | | +-----+--------------------+ | +-----------------------------------+ +------------------------------+ Nav只是一个常规组件 UserSettings是父视图组件 UserEmailsSubscriptions, UserProfile,UserProfilePreview是嵌套视图组件 注意：让我们忘记 HTML&#x2F;CSS 应该如何表示这种布局并关注所使用的组件。 上述布局中的组件&lt;template&gt;部分UserSettings如下所示： &lt;!-- UserSettings.vue --&gt; &lt;div&gt; &lt;h1&gt;User Settings&lt;/h1&gt; &lt;NavBar /&gt; &lt;router-view /&gt; &lt;router-view name=&quot;helper&quot; /&gt; &lt;/div&gt; 然后你可以用这个路由配置来实现上面的布局： &#123; path: &#39;/settings&#39;, // You could also have named views at the top component: UserSettings, children: [&#123; path: &#39;emails&#39;, component: UserEmailsSubscriptions &#125;, &#123; path: &#39;profile&#39;, components: &#123; default: UserProfile, helper: UserProfilePreview &#125; &#125;] &#125; 编程式导航除了使用 &lt;router-link&gt; 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。 导航到不同的位置 注意：在 Vue 实例中，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push。 想要导航到不同的 URL，可以使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL。 当你点击 &lt;router-link&gt; 时，内部会调用这个方法，所以点击 &lt;router-link :to=&quot;...&quot;&gt; 相当于调用 router.push(...) ： 声明式 编程式 &lt;router-link :to=&quot;...&quot;&gt; router.push(...) 该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如： // 字符串路径 router.push(&#39;/users/eduardo&#39;) // 带有路径的对象 router.push(&#123; path: &#39;/users/eduardo&#39; &#125;) // 命名的路由，并加上参数，让路由建立 url router.push(&#123; name: &#39;user&#39;, params: &#123; username: &#39;eduardo&#39; &#125; &#125;) // 带查询参数，结果是 /register?plan=private router.push(&#123; path: &#39;/register&#39;, query: &#123; plan: &#39;private&#39; &#125; &#125;) // 带 hash，结果是 /about#team router.push(&#123; path: &#39;/about&#39;, hash: &#39;#team&#39; &#125;) 注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path ： const username = &#39;eduardo&#39; // 我们可以手动建立 url，但我们必须自己处理编码 router.push(`/user/$&#123;username&#125;`) // -&gt; /user/eduardo // 同样 router.push(&#123; path: `/user/$&#123;username&#125;` &#125;) // -&gt; /user/eduardo // 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益 router.push(&#123; name: &#39;user&#39;, params: &#123; username &#125; &#125;) // -&gt; /user/eduardo // `params` 不能与 `path` 一起使用 router.push(&#123; path: &#39;/user&#39;, params: &#123; username &#125; &#125;) // -&gt; /user 由于属性 to 与 router.push 接受的对象种类相同，所以两者的规则完全相同。 router.push 和所有其他导航方法都会返回一个 Promise，让我们可以等到导航完成后才知道是成功还是失败。我们将在 Navigation Handling 中详细介绍。 替换当前位置 它的作用类似于 router.push，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。 声明式 编程式 &lt;router-link :to=&quot;...&quot; replace&gt; router.replace(...) 也可以直接在传递给 router.push 的 routeLocation 中增加一个属性 replace: true ： router.push(&#123; path: &#39;/home&#39;, replace: true &#125;) // 相当于 router.replace(&#123; path: &#39;/home&#39; &#125;) 横跨历史 该方法采用一个整数作为参数，表示在历史堆栈中前进或后退多少步，类似于 window.history.go(n)。 例子 // 向前移动一条记录，与 router.forward() 相同 router.go(1) // 返回一条记录，与router.back() 相同 router.go(-1) // 前进 3 条记录 router.go(3) // 如果没有那么多记录，静默失败 router.go(-100) router.go(100) 篡改历史 你可能已经注意到，router.push、router.replace 和 router.go 是 window.history.pushState、window.history.replaceState 和 window.history.go 的翻版，它们确实模仿了 window.history 的 API。 因此，如果你已经熟悉 Browser History APIs，在使用 Vue Router 时，操作历史记录就会觉得很熟悉。 值得一提的是，无论在创建路由器实例时传递什么样的history 配置，Vue Router 的导航方法(push、replace、go)都能始终如一地工作。 重定向和别名重定向#重定向也是通过 routes 配置来完成，下面例子是从 /home 重定向到 /： const routes = [&#123; path: &#39;/home&#39;, redirect: &#39;/&#39; &#125;] 重定向的目标也可以是一个命名的路由： const routes = [&#123; path: &#39;/home&#39;, redirect: &#123; name: &#39;homepage&#39; &#125; &#125;] 甚至是一个方法，动态返回重定向目标： const routes = [ &#123; // /search/screens -&gt; /search?q=screens path: &#39;/search/:searchText&#39;, redirect: to =&gt; &#123; // 方法接收目标路由作为参数 // return 重定向的字符串路径/路径对象 return &#123; path: &#39;/search&#39;, query: &#123; q: to.params.searchText &#125; &#125; &#125;, &#125;, &#123; path: &#39;/search&#39;, // ... &#125;, ] 请注意，**导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上**。在上面的例子中，在 /home 路由中添加 beforeEnter 守卫不会有任何效果。 在写 redirect 的时候，可以省略 component 配置，因为它从来没有被直接访问过，所以没有组件要渲染。唯一的例外是嵌套路由：如果一个路由记录有 children 和 redirect 属性，它也应该有 component 属性。 相对重定向#也可以重定向到相对位置： const routes = [ &#123; path: &#39;/users/:id/posts&#39;, redirect: to =&gt; &#123; // 方法接收目标路由作为参数 // return 重定向的字符串路径/路径对象 &#125;, &#125;, ] 别名#重定向是指当用户访问 /home 时，URL 会被 / 替换，然后匹配成 /。那么什么是别名呢？ 将 / 别名为 /home，意味着当用户访问 /home 时，URL 仍然是 /home，但会被匹配为用户正在访问 /。 上面对应的路由配置为： const routes = [&#123; path: &#39;/&#39;, component: Homepage, alias: &#39;/home&#39; &#125;] 通过别名，你可以自由地将 UI 结构映射到一个任意的 URL，而不受配置的嵌套结构的限制。使别名以 / 开头，以使嵌套路径中的路径成为绝对路径。你甚至可以将两者结合起来，用一个数组提供多个别名： const routes = [ &#123; path: &#39;/users&#39;, component: UsersLayout, children: [ // 为这 3 个 URL 呈现 UserList // - /users // - /users/list // - /people &#123; path: &#39;&#39;, component: UserList, alias: [&#39;/people&#39;, &#39;list&#39;] &#125;, ], &#125;, ] 如果你的路由有参数，请确保在任何绝对别名中包含它们： const routes = [ &#123; path: &#39;/users/:id&#39;, component: UsersByIdLayout, children: [ // 为这 3 个 URL 呈现 UserDetails // - /users/24 // - /users/24/profile // - /24 &#123; path: &#39;profile&#39;, component: UserDetails, alias: [&#39;/:id&#39;, &#39;&#39;] &#125;, ], &#125;, ] 路由组件传参将 props 传递给路由组件# 在你的组件中使用 $route 会与路由紧密耦合，这限制了组件的灵活性，因为它只能用于特定的 URL。虽然这不一定是件坏事，但我们可以通过 props 配置来解除这种行为： 我们可以将下面的代码 const User = &#123; template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39; &#125; const routes = [&#123; path: &#39;/user/:id&#39;, component: User &#125;] 替换成 const User = &#123; props: [&#39;id&#39;], template: &#39;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#39; &#125; const routes = [&#123; path: &#39;/user/:id&#39;, component: User, props: true &#125;] 布尔模式#当 props 设置为 true 时，route.params 将被设置为组件的 props。 命名视图#对于有命名视图的路由，你必须为每个命名视图定义 props 配置： const routes = [ &#123; path: &#39;/user/:id&#39;, components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ] 对象模式#当 props 是一个对象时，它将原样设置为组件 props。当 props 是静态的时候很有用。 const routes = [ &#123; path: &#39;/promotion/from-newsletter&#39;, component: Promotion, props: &#123; newsletterPopup: false &#125; &#125; ] 函数模式#你可以创建一个返回 props 的函数。这允许你将参数转换为其他类型，将静态值与基于路由的值相结合等等。 const routes = [ &#123; path: &#39;/search&#39;, component: SearchUser, props: route =&gt; (&#123; query: route.query.q &#125;) &#125; ] URL /search?q=vue 将传递 &#123;query: &#39;vue&#39;&#125; 作为 props 传给 SearchUser 组件。 请尽可能保持 props 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 props，请使用包装组件，这样 vue 才可以对状态变化做出反应。 不同的历史记录模式官方推荐HTML5模式import &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39; const router = createRouter(&#123; history: createWebHistory(), routes: [ //... ], &#125;) 当使用这种历史模式时，URL 会看起来很 “正常”，例如 https://example.com/user/id。漂亮! 不过，问题来了。由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 https://example.com/user/id，就会得到一个 404 错误。这就丑了。 不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 index.html 相同的页面。漂亮依旧! 导航卫士动态路由VuexVuex 是一个为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用程序的所有组件的状态，并以相应的规则保证以一种状态可发生变化的方式。","categories":[],"tags":[]},{"title":"Vue","slug":"4-25/Vue","date":"2022-04-25T06:36:06.433Z","updated":"2022-04-26T10:42:19.929Z","comments":true,"path":"2022/04/25/4-25/Vue/","link":"","permalink":"https://dddwah11.github.io/2022/04/25/4-25/Vue/","excerpt":"","text":"网络通信: axios 网页跳转：vue_router 状态管理：vuex Vue-UI: ICE ElementUI、 UI框架：iview Ant-Design、Bootstrap AmazeUI、layui、vue-element-admin JavaScript构建工具： WebPack:打包、压缩、合并、按序加载 MVVM模型 view model view model 条件判断&lt;div id=&quot;app&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123;item.message&#125;&#125; &lt;/li&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:&quot;#app&quot;, data: &#123; items: [ &#123;message: &#39;xiaoliu&#39;&#125;, &#123;message: &#39;xiaoliuu&#39;&#125; ] &#125; &#125;); &lt;/script&gt; &lt;/body&gt; 鼠标悬停&lt;div id=&quot;app&quot;&gt; &lt;span v-bind:title=&quot;message&quot;&gt; 鼠标悬停几秒查看此处动态绑定的提示消息! &lt;/span&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:&quot;#app&quot;, data:&#123; message:&quot;hello,vue&quot; &#125; &#125;); &lt;/script&gt; 事件&lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;sayHi&quot;&gt;点我&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:&quot;#app&quot;, data: &#123;&#125;, methods: &#123; //方法必须定义在methods方法对象中 sayHi: function () &#123; alert(this.message) &#125; &#125; &#125;); &lt;/script&gt; Vue7大属性1.el属性 用来指示vue编译器从什么地方开始解析 vue的语法，可以说是一个占位符。相当于一个容器，跟上面的div id &#x3D; “app”做关联，从此以后上面div id &#x3D; “app”里面的内容要通过vue来渲染,都要经过vue处理才能看得到上面div里面的内容 2.data属性用来组织从view中抽象出来的属性，可以说将视图的数据抽象出来存放在data中。跟微信小程序一样，所有的变量都要写在data里面 3.template属性用来设置模板，会替换页面元素，包括占位符。Vue.component（）组件中会用到，其实很多地方都会用到 4.methods属性放置页面中的业务逻辑，js方法一般都放置在methods中，用来写方法，函数的computed后面会介绍computed和methods是有区别的：computed是在值发生改变的时候才会触发效果，而methods只要刷新执行了就会触发，所有平时写VUE的时候，能用computed的尽量使用 5.render属性创建真正的Virtual Dom 6.computed属性用来计算根据已经存在的属性计算出新的属性，对于同样的数据，会缓存。当其依赖属性的值发生变化是，这个属性的值会自动更新，与之相关的DOM部份也会同步自动更新。其实一般情况，我也会把一些关于逻辑的代码都写在computed中。 7.watch侦听属性watch:function(new,old){}监听data中数据的变化两个参数，一个返回新值，一个返回旧值当你有一些数据需要随着其它数据变动而变动时或者执行异步操作或开销较大操作时，建议使用watchcomputed和watch是有区别的：watch: 监视,能够监听到数据的变化,只要数据变化的时候,都会自定执行对应的方法,其中可以检测的数据来源分为三部分 data , computed , props computed: 计算属性,存在一个计算缓存的特性,每一次计算之后,只要里面的逻辑不发生变化,每一次重复调用,都会使用上一次执行的结果,能够节省计算的时间 在表单实现数据的双向绑定 &lt;div id=&quot;app&quot;&gt; &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot; v-model=&quot;message&quot;&gt;&lt;/textarea&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:&quot;#app&quot;, data: &#123; message:&#39;&#39; &#125;, &#125;); &lt;/script&gt; 同步输入框 &lt;div id=&quot;app&quot;&gt; 性别： &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; v-model=&quot;message&quot;&gt; 男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; v-model=&quot;message&quot;&gt; 女 &lt;p&gt;选中了：&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:&quot;#app&quot;, data: &#123; message:&#39;&#39; &#125;, &#125;); &lt;/script&gt; 组件自定义组件获取值： &lt;div id=&quot;app&quot;&gt; &lt;xiaoliu v-for=&quot;item in items&quot; v-bind:item=&quot;item&quot;&gt;&lt;/xiaoliu&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;xiaoliu&quot;,&#123; props: [&#39;item&#39;], template: &#39;&lt;h1&gt;&#123;&#123;item&#125;&#125;&lt;/h1&gt;&#39; //模板 &#125;) var vm = new Vue(&#123; el:&quot;#app&quot;, data: &#123; message:&#39;&#39;, items: [&quot;xiaoliu&quot;,&quot;xiaoliuu&quot;,&quot;xiaoliuuu&quot;] &#125;, &#125;); &lt;/script&gt; Axios异步通信json数据： &#123; &quot;name&quot;:&quot;狂神说java&quot;, &quot;url&quot;: &quot;http://baidu.com&quot;, &quot;page&quot;: &quot;1&quot;, &quot;isNonProfit&quot;:&quot;true&quot;, &quot;address&quot;: &#123; &quot;street&quot;: &quot;含光门&quot;, &quot;city&quot;:&quot;陕西西安&quot;, &quot;country&quot;: &quot;中国&quot; &#125;, &quot;links&quot;: [ &#123; &quot;name&quot;: &quot;B站&quot;, &quot;url&quot;: &quot;https://www.bilibili.com/&quot; &#125;, &#123; &quot;name&quot;: &quot;4399&quot;, &quot;url&quot;: &quot;https://www.4399.com/&quot; &#125;, &#123; &quot;name&quot;: &quot;百度&quot;, &quot;url&quot;: &quot;https://www.baidu.com/&quot; &#125; ] &lt;!--导入JS文件--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;div id=&quot;vue&quot;&gt;&lt;/div&gt; &lt;!--导入JS文件--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/nmp/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min .js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &quot;#vue&quot;, data()&#123; return&#123; info:&#123; name:null, address:&#123; street:null, city: null, country: null &#125; &#125; &#125; &#125;, mounted()&#123;//钩子函数，链式编程 axios.get(&#39;data.json&#39;).then(response=&gt;(this.info=response.data)); &#125; &#125;); &lt;/script&gt; 解决数据闪烁问题 &lt;style&gt; [v-clock]&#123; display: none; &#125; &lt;/style&gt; 在head标签内，没加载数据时白屏 计算属性computed:&#123;//计算属性 methods computed中能重名，优先调用方法 currentTime1: function () &#123; return Date.now(); &#125; &#125; 返回的是属性 slot（插槽）&lt;div id=&quot;vue&quot;&gt; &lt;todo&gt; &lt;todo-title slot=&quot;todo-title&quot; :title=&quot;title&quot;&gt;&lt;/todo-title&gt; &lt;todo-item slot=&quot;todo-item&quot; v-for=&quot;items in item&quot; :item=&quot;items&quot;&gt;&lt;/todo-item&gt; &lt;/todo&gt; &lt;/div&gt; &lt;!--导入JS文件--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&quot;todo&quot;,&#123; template: &#39;&lt;div&gt;&#39; + &#39;&lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;&#39; + &#39;&lt;ul&gt;&#39; + &#39;&lt;slot name=&quot;todo-item&quot;&gt;&lt;/slot&gt;&#39; + &#39;&lt;/ul&gt;&gt;&#39; + &#39;&lt;/div&gt;&#39; &#125;); Vue.component(&quot;todo-title&quot;,&#123; props: [&#39;title&#39;], template: &#39;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#39; &#125;); Vue.component(&quot;todo-item&quot;,&#123; props: [&#39;item&#39;], template: &#39;&lt;div&gt;&#123;&#123;item&#125;&#125; &lt;button @click=&quot;remove&quot;&gt;删除&lt;/button&gt; &lt;/div&gt;&#39;, methods: &#123; remove: function () &#123; alert(&quot;删除成功&quot;) &#125; &#125; &#125;); var vm = new Vue(&#123; el: &quot;#vue&quot;, data: &#123; title: &quot;xiaoliu&quot;, todo: [&#39;效率&#39;,&#39;小刘&#39;], item: [&#39;wo&#39;,&#39;we&#39;] &#125; &#125;); &lt;/script&gt; 自定义事件删除操作要在组件中完成，涉及参数传递与事件分发，可以使用this.$emit( ‘ 自定义事件名 ‘ , 参数) &lt;div id=&quot;vue&quot;&gt; &lt;todo&gt; &lt;todo-title slot=&quot;todo-title&quot; :title=&quot;title&quot;&gt;&lt;/todo-title&gt; &lt;todo-item slot=&quot;todo-item&quot; v-for=&quot;(items,index) in item&quot; :item=&quot;items&quot; v-bind:index=&quot;index&quot; v-on:remove=&quot;removeItem(index)&quot; :key=&quot;index&quot;&gt;&lt;/todo-item&gt; &lt;/todo&gt; &lt;/div&gt; &lt;!--导入JS文件--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&quot;todo&quot;,&#123; template: &#39;&lt;div&gt;&#39; + &#39;&lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;&#39; + &#39;&lt;ul&gt;&#39; + &#39;&lt;slot name=&quot;todo-item&quot;&gt;&lt;/slot&gt;&#39; + &#39;&lt;/ul&gt;&gt;&#39; + &#39;&lt;/div&gt;&#39; &#125;); Vue.component(&quot;todo-title&quot;,&#123; props: [&#39;title&#39;], template: &#39;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#39; &#125;); Vue.component(&quot;todo-item&quot;,&#123; props: [&#39;item&#39;,&#39;index&#39;], template: &#39;&lt;div&gt;&#123;&#123;index&#125;&#125;----&#123;&#123;item&#125;&#125; &lt;button @click=&quot;remove&quot;&gt;删除&lt;/button&gt; &lt;/div&gt;&#39;, methods: &#123; remove: function (index) &#123; this.$emit(&#39;remove&#39;,index); &#125; &#125; &#125;); var vm = new Vue(&#123; el: &quot;#vue&quot;, data: &#123; title: &quot;xiaoliu&quot;, todo: [&#39;效率&#39;,&#39;小刘&#39;], item: [&#39;wo&#39;,&#39;we&#39;] &#125;, methods: &#123; removeItem: function (index) &#123; console.log(&quot;shanchu&quot;+this.item[index]+&quot;ok&quot;); this.item.splice(index,1); &#125; &#125; &#125;); &lt;/script&gt;","categories":[],"tags":[]},{"title":"","slug":"4-24/微服务","date":"2022-04-24T09:58:23.676Z","updated":"2022-04-24T10:49:48.540Z","comments":true,"path":"2022/04/24/4-24/微服务/","link":"","permalink":"https://dddwah11.github.io/2022/04/24/4-24/%E5%BE%AE%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"分布式-Dubbo-Zookeeper","slug":"4-23/分布式系统理论","date":"2022-04-23T09:00:14.508Z","updated":"2022-04-23T15:53:57.249Z","comments":true,"path":"2022/04/23/4-23/分布式系统理论/","link":"","permalink":"https://dddwah11.github.io/2022/04/23/4-23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/","excerpt":"","text":"安装zookeeper https://archive.apache.org/dist/zookeeper/zookeeper-3.7.0/ 下载编译后二进制的包 运行bin目录下的zkServer.cmd windows下 闪退解决：修改配置文件 加个暂停(pause)查看错误的原因 原因是conf目录下没有 zoo.cfg 复制sample进行添加 连接服务zkServer.cmd 连接客户端zkCli.cmd 在项目中打包dubbo-admin mvn clean package -Dmaven.test.skip=true admin的地址为7001 默认账号密码都是 root dubbo-admin是一个监控管理后台，查看我们哪些服务注册，被消费 zookeeper是 注册中心 导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; 日志冲突 &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 配置文件 #服务应用名字 dubbo.application.name=provider #注册中心地址 dubbo.registry.address=zookeeper://127.0.1:2181 #哪些服务需要被注册 dubbo.scan.base-packages=com.xiaoliu.service 接下来再导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; 这个需要排除sl4j的依赖 #消费者需要去哪拿服务需要暴露名字 dubbo.application.name=provider #去注册中心 dubbo.registry.address=zookeeper://127.0.1:2181 消费者业务接口 消费者生产者接口都必须相同 @Service public class Service&#123; @Reference//引用，Pom坐标，可以定义路径相同的接口名，远程引用 TicketService ticketService; public void buyTicket()&#123; String ticket = ticketService.getTicket(); System.out.println(&quot;拿到票&quot;+ticket); &#125; &#125; 1、提供者提供服务 ​ 1.导入依赖 ​ 2.配置注册中心地址，以及服务发现名，和要扫描的包 ​ 3.在想要被注册的服务上面 增加一个注解 @Service 2、消费者如何消费 ​ 1.导入依赖 ​ 2.配置注册中心地址，配置自己的服务名 ​ 3.从远程注入服务 @Reference","categories":[],"tags":[]},{"title":"任务","slug":"4-23/异步任务","date":"2022-04-23T06:18:43.181Z","updated":"2022-04-23T08:59:16.750Z","comments":true,"path":"2022/04/23/4-23/异步任务/","link":"","permalink":"https://dddwah11.github.io/2022/04/23/4-23/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"异步任务在业务需要异步处理的方法加入注解 @Async 在启动类加入 @EnableAsync 在控制层加入加入业务即可 邮件任务这里用qq邮件 配置文件 #开启加密验证 spring.mail.properties.mail.smtp.ssl.enable=true spring.mail.username=1937589397@qq.com spring.mail.password=ixxxxxxxxxxb spring.mail.host=smtp.qq.com @Autowired JavaMailSender mailSender; @Test void contextLoads() &#123; // 发送邮件 // 发件人 // 内容 SimpleMailMessage message = new SimpleMailMessage(); message.setSubject(&quot;小刘&quot;); message.setText(&quot;hello&quot;); message.setFrom(&quot;1937589397@qq.com&quot;); message.setTo(&quot;1937589397@qq.com&quot;); mailSender.send(message); &#125; 复杂邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); // 组装 MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true); helper.setSubject(subject); helper.setText(text,true); // 附件 helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;D:\\\\壁纸\\\\5b8b4cf6143640c98cd46cd77d26f292.jpg&quot;)); helper.setTo(&quot;1937589397@qq.com&quot;); helper.setFrom(&quot;1937589397@qq.com&quot;); mailSender.send(mimeMessage); 定时执行任务TaskeScheduler 任务调度者 TaskExecutor 认为执行者 @EnableScueduling开启定时功能的注解在启动类 @Scheduled 什么时候执行 Cron表达式 @Service public class ScheduleService &#123; // cron表达 // 秒 分 时 日 月 周几 // 下面表达式表示是 每一周的每0秒执行 //@Scheduled(cron = &quot;0 * * * * 0-7&quot;) // 下面表达的是 每一天天的16时 44分 执行 @Scheduled(cron = &quot;1 48 16 * * ?&quot;) // 30 0/5 10 18, * ? 每天 10点和18点 每隔五分钟执行一次 public void hello()&#123; System.out.println(&quot;您被执行了&quot;); &#125; &#125;","categories":[],"tags":[]},{"title":"swagger","slug":"4-22/swagger","date":"2022-04-22T08:42:39.305Z","updated":"2022-04-23T06:18:47.217Z","comments":true,"path":"2022/04/22/4-22/swagger/","link":"","permalink":"https://dddwah11.github.io/2022/04/22/4-22/swagger/","excerpt":"","text":"Swagger简介 前后端分离 Vue + SpringBoot Swagger最流行的API框架 在项目中使用swagger需要springfox； swagger2 ui spirngboot集成swagger1、新建springweb项目 2、导入依赖 &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; 3、配置swagger @Configuration @EnableSwagger2//开启swagger2 public class SwaggerConfig &#123; &#125; 测试页面 http://localhost:8080/swagger-ui.html swagger的bean实例 Docket SwaggerConfig package com.xiaoliu.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.RequestHandler; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; import java.util.ArrayList; /** * @author: 61分 * @date: 2022/4/22 17:39 * @description: */ @Configuration @EnableSwagger2//开启swagger2 public class SwaggerConfig &#123; // 配置swagger的Docket bean实例 @Bean public Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) &#125; // 配置swagger信息=apiinfo private ApiInfo apiInfo()&#123; System.out.println(&quot;doswagger&quot;); // 作者信息 Contact contact = new Contact(&quot;xiaoliu&quot;, &quot;https://dddwah11.github.io/&quot;, &quot;1937589397@qq.com&quot;); return new ApiInfo( &quot;APIInfo&quot;, &quot;swagger配置&quot;, &quot;v1.0&quot;, &quot;https://dddwah11.github.io/&quot;, contact, &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LINCENSE-2.0&quot;, new ArrayList&lt;&gt;() ); &#125; &#125; Swagger配置扫描接口Docket.select() .enable(false);// .select() // RequestHandlerSelectors配置需要扫描接口的方式 // basePackage指定要扫描的包 // any()扫描全部 // none()都不扫描 // withClassAnnotation;扫描类上的注解，参数是一个注解的反射对象 // withMethodAnnotation;扫描方法上的注解 .apis(RequestHandlerSelectors.basePackage(&quot;com.xiaoliu.helloController&quot;)) // path()过滤路径 .build(); 配置是否启动swagger .enable(false);//不启动swagger .select() 我们希望swagger在生产环境中使用，在发布时不使用 判断是不是生产环境 注入 enable() @Bean public Docket docket(Environment environment)&#123; // 设置要显示的flag环境 Profiles profiles =Profiles.of(&quot;dev&quot;,&quot;test&quot;); // 获取项目环境 // 通过environment.acceptsProfiles判断是否处在自己设定的环境 boolean b = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(b) 配置文件中设置生产和发布环境 主配置文件设置 spring.profiles.active=当前环境 swagger配置API文档分组.apiInfo(apiInfo()) .groupName(&quot;hello&quot;) 如何配置多个分组 @Bean public Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;A&quot;); &#125; @ApiModel()//文档注释","categories":[],"tags":[]},{"title":"shiro安全框架 -springboot中集成","slug":"4-21/shiro","date":"2022-04-21T07:14:33.034Z","updated":"2022-04-21T16:22:20.875Z","comments":true,"path":"2022/04/21/4-21/shiro/","link":"","permalink":"https://dddwah11.github.io/2022/04/21/4-21/shiro/","excerpt":"","text":"1、导入依赖 2、配置文件 3、应用程序 获取当前对象 Subject currentUser = SecurityUtils.getSubject(); 获取当前session Session session = currentUser.getSession(); 判断用户是否被认证 currentUser.isAuthenticated() 获取当前认证 currentUser.getPrincipal() 用户角色 currentUser.hasRole 粗粒度 currentUser.isPermitted(&quot;lightsaber:wield&quot;) 细粒度 currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;) 登出 currentUser.logout() shiro登录认证1、创建realm对象，需要自定义类： public class UserRealm extends AuthorizingRealm &#123; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;授权doGetAuthorizationInfo&quot;); return null; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;认证doGetAuthenticationInfo&quot;); return null; &#125; &#125; @Configuration public class shiroConfig &#123; // ShiroFilterFactoryBean // Manager // 创建realm对象 @Bean public UserRealm userRealm()&#123; return new UserRealm(); &#125; &#125; 2、defaultWebSecurityManager @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm)&#123; DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager(); defaultWebSecurityManager.setRealm(userRealm); // 关联realm return defaultWebSecurityManager; &#125; 3、shiroFiterFactoryBean @Bean(name = &quot;DefaultWebSecurityManager&quot;) public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;DefaultWebSecurityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 关联webSecurityManager shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager); return shiroFilterFactoryBean; &#125; ShiroFilterFactoryBean @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); // 关联webSecurityManager // 设置安全管理器 bean.setSecurityManager(defaultWebSecurityManager); // 添加shiro的内置过滤器 /* anon:无需认证 authc: 必须认证 user: 必须拥有 记住我 功能才能实现 perms: 拥有对某个资源权限功能才能能访问 role: 拥有某个角色权限 */ Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(&quot;/user/add&quot;,&quot;authc&quot;); filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;); System.out.println(&quot;filterMap&quot;); bean.setFilterChainDefinitionMap(filterMap); return bean; &#125; 可在ShiroFilterFactoryBean 设置登录 bean.setLoginUrl(&quot;/toLogin&quot;); shiro实现用户认证在Controller中 @RequestMapping(&quot;/login&quot;) public String login(String username,String password)&#123; // 获取对象 Subject subject = SecurityUtils.getSubject(); // 封装登录对象的数据为token UsernamePasswordToken token = new UsernamePasswordToken(username, password); subject.login(token); try &#123; subject.login(token);//执行登录方法，无异常就执行 return &quot;index&quot;; &#125; catch (UnknownAccountException e) &#123;//用户名不存在 model.addAttribute(&quot;msg&quot;,&quot;用户名错误&quot;); return &quot;login&quot;; &#125; catch (IncorrectCredentialsException e)&#123;//密码不存在 model.addAttribute(&quot;msg&quot;,&quot;密码错误&quot;); return &quot;login&quot;; &#125; catch (LockedAccountException e)&#123; model.addAttribute(&quot;msg&quot;,&quot;账号被锁定&quot;); return &quot;login&quot;; &#125; &#125; UserRealm类中 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;认证doGetAuthenticationInfo&quot;); // 用户名，密码，数据库中取 String username= &quot;root&quot;; String password= &quot;123456&quot;; UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; if (!token.getUsername().equals(username))&#123; return null;//抛出异常UnknownAccountException &#125; // 密码认证shiro做 return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;); &#125; Shiro整合Mybatis搭建脚手架并测试，通过再进行下面的测试 在UserRealm中导入业务层接口 @Autowired UserService userService; // 连接数据库 UsernamePasswordToken userToken = (UsernamePasswordToken) authenticationToken; User user = userService.queryUserByName(userToken.getUsername()); if (user==null)&#123; //查无此人 return null;//UnknownAccountException &#125; // 密码认证shiro做 return new SimpleAuthenticationInfo(&quot;&quot;,user.getPassword(),&quot;&quot;); &#125; UserRealm类中 // 连接数据库 UsernamePasswordToken userToken = (UsernamePasswordToken) authenticationToken; User user = userService.queryUserByName(userToken.getUsername()); if (user==null)&#123; //查无此人 return null;//UnknownAccountException &#125; // 加密：MD5加密，MD5盐值加密 // md5：xwefqbrb134513451223qwer md5+盐值： xwefqbrb134513451223qwerusername // 密码认证shiro做，加密了 // 密码认证shiro做 return new SimpleAuthenticationInfo(&quot;&quot;,user.getPassword(),&quot;&quot;); &#125; Shiro请求授权实现 在shiroConfig类中 // 授权 filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;); 设置未授权的请求 // 设置未授权的请求 bean.setUnauthorizedUrl(&quot;/noauth&quot;); 设置Controller @RequestMapping(&quot;/noauth&quot;) @ResponseBody public String unauthorized()&#123; return &quot;未经授权无法访问该页面&quot;; &#125; 编写controller层 @RequestMapping(&quot;/noauth&quot;) @ResponseBody public String unauthorized()&#123; return &quot;未经授权无法访问该页面&quot;; &#125; 授权、//授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;授权doGetAuthorizationInfo&quot;); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addStringPermission(&quot;user:add&quot;);//这行是全部人都获取授权，想指定的人获得授权就注释这行 return info; &#125; 指定数据库中的某些用户获取数据 数据库中设定权限 UserRealm类中 // 拿到当前登录的对象 Subject subject = SecurityUtils.getSubject(); User currentUser = (User)subject.getPrincipal();//拿到user对象 info.addStringPermission(currentUser.getPerms()); return info; shiroConfig类中 filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;); filterMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;); Shiro整合Thymeleaf导入依赖 shiro-thymeleaf &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; 在UserRealm类中 // 整合shirodialect：整合 th 和 shiro @Bean public ShiroDialect getshiroDialect()&#123; return new ShiroDialect(); &#125;","categories":[],"tags":[]},{"title":"整合Mybatis","slug":"4-18/整合中Mybatis","date":"2022-04-18T07:16:30.446Z","updated":"2022-04-18T13:44:42.616Z","comments":true,"path":"2022/04/18/4-18/整合中Mybatis/","link":"","permalink":"https://dddwah11.github.io/2022/04/18/4-18/%E6%95%B4%E5%90%88%E4%B8%ADMybatis/","excerpt":"","text":"准备工作：搭建环境并测试（导入包，配置文件，myabtis配置，编写sql） 1、编写实体类package com.xiaoliu.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /** * @author: 61分 * @date: 2022/4/18 15:29 * @description: */ @Data @AllArgsConstructor @NoArgsConstructor public class User &#123; private Integer id; private String name; private String password; &#125; 2、编写接口package com.xiaoliu.mapper; /** * @author: 61分 * @date: 2022/4/18 15:32 * @description: */ @org.apache.ibatis.annotations.Mapper public interface Mapper &#123; &#125; @Repository //Dao层 用该注解 再到resource目录下配置xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.xiaoliu.mapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;User&quot;&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 在springboot中配置文件别名及mapper.xml文件 mybatis.type-aliases-package=com.xiaoliu.pojo mybatis.mapper-locations=classpath:/mybatis/mapper/*.xml 增删改查 &lt;select id=&quot;queryUserListById&quot; resultType=&quot;User&quot;&gt; select * from mybatis.user where id = #&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;queryUserList&quot; resultType=&quot;User&quot;&gt; select * from mybatis.user &lt;/select&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;User&quot;&gt; insert into mybatis.user (id, name, password) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;); &lt;/insert&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt; update mybatis.user set name = #&#123;name&#125;, password = #&#123;password&#125; where id = #&#123;id&#125;; 配置文件： # 应用名称 spring.application.name=mybatisSpringboot # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据源名称 spring.datasource.name=defaultDataSource # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 # 数据库用户名&amp;密码： spring.datasource.username=root spring.datasource.password=123456 # 应用服务 WEB 访问端口 server.port=8080 mybatis.type-aliases-package=com.xiaoliu.pojo mybatis.mapper-locations=classpath:/mybatis/mapper/*.xml","categories":[],"tags":[]},{"title":"整合Druid","slug":"4-18/整合druid","date":"2022-04-18T06:31:03.389Z","updated":"2022-04-18T07:16:17.307Z","comments":true,"path":"2022/04/18/4-18/整合druid/","link":"","permalink":"https://dddwah11.github.io/2022/04/18/4-18/%E6%95%B4%E5%90%88druid/","excerpt":"","text":"1、导入相关依赖&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.9&lt;/version&gt; &lt;/dependency&gt; 2、配置文件type: com.alibaba.druid.pool.DruidDataSource #SpringBoot默认是不注入这些的，需要自己绑定 #druid数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat：监控统计、log4j：日志记录、wall：防御sql注入 #如果允许报错，java.lang.ClassNotFoundException: org.apache.Log4j.Properity #则导入log4j 依赖就行 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 配置进去没用，也能进去，先放着 3、绑定配置文件package com.xiaoliu.config; import com.alibaba.druid.pool.DruidDataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; /** * @author: 61分 * @date: 2022/4/18 14:33 * @description: */ @Configuration public class DruidConfig &#123; @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource DruidDataSource()&#123; return new DruidDataSource(); &#125; &#125; 4、DruidConfigpackage com.xiaoliu.config; import com.alibaba.druid.pool.DruidDataSource; import com.alibaba.druid.support.http.StatViewServlet; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; import java.util.HashMap; /** * @author: 61分 * @date: 2022/4/18 14:33 * @description: */ @Configuration public class DruidConfig &#123; @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource DruidDataSource()&#123; return new DruidDataSource(); &#125; // 后台监控:web.xml // springboot集成了servlet，没有web.xml 可以使用ServletRegistrationBean，注册 @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;); // 后台有人登陆，账号密码配置 HashMap&lt;String, String&gt; initParameter = new HashMap&lt;&gt;(); // 设置参数 initParameter.put(&quot;loginUsername&quot;, &quot;admin&quot;);//默认的数值 initParameter.put(&quot;loginPassword&quot;,&quot;123456&quot;);//默认的数值 // 允许谁访问 initParameter.put(&quot;allow&quot;,&quot;&quot;);//后面参数不写，任何人都能访问 // 禁止谁访问 initParameter.put(&quot;xxx&quot;,&quot;ip地址&quot;); bean.setInitParameters(initParameter);//设置初始化参数 return bean; &#125; &#125; 过滤器 // filter @Bean public FilterRegistrationBean filterStart()&#123; FilterRegistrationBean&lt;Filter&gt; bean = new FilterRegistrationBean&lt;&gt;(); bean.setFilter(new WebStatFilter()); // 设置过滤请求 HashMap&lt;String, String&gt; initParameters = new HashMap&lt;&gt;(); // 设置不统计的东西 initParameters.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParameters); return bean; &#125;","categories":[],"tags":[]},{"title":"springWeb-02开发","slug":"4-16/springboot-web-02","date":"2022-04-16T14:15:45.600Z","updated":"2022-04-17T14:46:06.241Z","comments":true,"path":"2022/04/16/4-16/springboot-web-02/","link":"","permalink":"https://dddwah11.github.io/2022/04/16/4-16/springboot-web-02/","excerpt":"","text":"员工列表展示 提前公共页面 &#96;th:replace&#x3D;”~{commons&#x2F;commons::sidebar&#96;&#96; &#96;&#96;&#96; 如果要传参，可以直接使用（）传参，接受判断 列表循坏展示 &#96; &lt;td th:text&#x3D;”$","categories":[],"tags":[]},{"title":"springWeb开发","slug":"4-16/springboot-web开发","date":"2022-04-16T05:16:40.666Z","updated":"2022-04-16T14:15:31.726Z","comments":true,"path":"2022/04/16/4-16/springboot-web开发/","link":"","permalink":"https://dddwah11.github.io/2022/04/16/4-16/springboot-web%E5%BC%80%E5%8F%91/","excerpt":"","text":"1、首页配置：所有html页面使用thymeleaf接管：url:@&#123;&#125; 首页： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;&quot;&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link th:href=&quot;@&#123;/css/bootstrap.min.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- Custom styles for this template --&gt; &lt;link th:href=&quot;@&#123;/css/signin.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body class=&quot;text-center&quot;&gt; &lt;form class=&quot;form-signin&quot; action=&quot;dashboard.html&quot;&gt; &lt;img class=&quot;mb-4&quot; th:src=&quot;@&#123;/img/bootstrap-solid.svg&#125;&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;72&quot;&gt; &lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot;&gt;Please sign in&lt;/h1&gt; &lt;label class=&quot;sr-only&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; required=&quot;&quot; autofocus=&quot;&quot;&gt; &lt;label class=&quot;sr-only&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required=&quot;&quot;&gt; &lt;div class=&quot;checkbox mb-3&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot;&gt;Sign in&lt;/button&gt; &lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;© 2017-2018&lt;/p&gt; &lt;a class=&quot;btn btn-sm&quot;&gt;中文&lt;/a&gt; &lt;a class=&quot;btn btn-sm&quot;&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; controller： package com.xiaoliu.config; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.ViewControllerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * @author: 61分 * @date: 2022/4/15 21:17 * @description: */ //扩展 springmvc dispatcherservlet @Configuration public class MyMvcConfig implements WebMvcConfigurer &#123; //视图跳转 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;index&quot;); &#125; &#125; 2、页面国际化i18n 设置login.properties文件， login.tip login.password login.username login.remember 怎么识别国际化 通过SpirngBoot——MessageSourceAutofiguration类 在配置application.properties spring.messages.basename=i18n.login thymeleaf国际化消息语法：#&#123;&#125; th:text=&quot;#&#123;login.password&#125;&quot; 实现语言切换 th:href=&quot;@&#123;/index.html(l=&#39;zh_CN&#39;)&#125;&quot;&gt;中文 th:href=&quot;@&#123;/index.html(l=&#39;en_US&#39;)&#125;&quot;&gt;Englis div自己的组件在config中的MyMvcConfig类中 并将其配置到springboot容器中 @Bean // 向容器中注入组件，自定义的国际化组件 @Bean public LocaleResolver localeResolver()&#123; return new MylocalResolver(); &#125; 自定义的组件 package com.xiaoliu.config; import org.springframework.util.StringUtils; import org.springframework.web.servlet.LocaleResolver; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Locale; /** * @author: 61分 * @date: 2022/4/16 15:22 * @description: */ public class MylocalResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; // 获取语言参数 String language = httpServletRequest.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault(); //如果没有就使用默认的 // 如果请求中携带了地区化的参数 if (!StringUtils.isEmpty(language))&#123; // 分割 zh_CN String[] split = language.split(&quot;_&quot;); // 国家 地区 locale = new Locale(split[0], split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125; &#125; 修改返回的url在自定义的视图跳转MyMvcConfig中 视图跳转到dashboard的时候 名字为：main.html registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;dashboard&quot;); 在controller返回重定向的页面为&#x2F;main.html if (!StringUtils.isEmpty(username) &amp;&amp; &quot;123&quot;.equals(password)) &#123; return &quot;redirect:/main.html&quot;; 拦截器在config中 编写LoginHandlerInterceptor拦截器 package com.xiaoliu.config; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @author: 61分 * @date: 2022/4/16 16:14 * @description: */ public class LoginHandlerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 登录之后应该有用户的session Object loginUser = request.getSession().getAttribute(&quot;loginUser&quot;); if (loginUser==null)&#123; request.setAttribute(&quot;msg&quot;,&quot;没有权限，请先登录！&quot;); request.getRequestDispatcher(&quot;/index.html&quot;).forward(request,response); return false; &#125;else return true; &#125; &#125; 在mvc类中重写拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()) .addPathPatterns(&quot;/**&quot;)//拦截的页面 .excludePathPatterns(&quot;/&quot;,&quot;/index.html&quot;,&quot;/user/login&quot;,&quot;/css/**&quot;,&quot;/js/**&quot;,&quot;/img/**&quot;);//不能被拦截的页面 &#125;","categories":[],"tags":[]},{"title":"通过java自建数据表","slug":"4-16/在javav中建立数据表","date":"2022-04-15T16:12:57.936Z","updated":"2022-04-15T16:16:08.051Z","comments":true,"path":"2022/04/16/4-16/在javav中建立数据表/","link":"","permalink":"https://dddwah11.github.io/2022/04/16/4-16/%E5%9C%A8javav%E4%B8%AD%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E8%A1%A8/","excerpt":"","text":"建立一个员工部门表：pojo:Employee: package com.xiaoliu.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.util.Date; /** * @author: 61分 * @date: 2022/4/15 23:12 * @description: */ @Data @NoArgsConstructor public class Employee &#123; private Integer id; private String lastName; private String email; private Integer gender; private Department department; private Date birth; public Employee(Integer id, String lastName, String email, Integer gender, Department department) &#123; this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; this.department = department; this.birth = new Date(); &#125; &#125; Department: package com.xiaoliu.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /** * @author: 61分 * @date: 2022/4/15 22:17 * @description: */ @Data @AllArgsConstructor @NoArgsConstructor public class Department &#123; private Integer id; private String department; &#125; Dao层：EmployeeDao： package com.xiaoliu.dao; import com.xiaoliu.pojo.Department; import com.xiaoliu.pojo.Employee; import org.springframework.beans.factory.annotation.Autowired; import java.util.Collection; import java.util.HashMap; import java.util.Map; /** * @author: 61分 * @date: 2022/4/15 23:44 * @description: */ public class EmployeeDao &#123; private static Map&lt;Integer, Employee&gt; employees; @Autowired private DepartmentDao departmentDao; static &#123; employees = new HashMap&lt;Integer, Employee&gt;();//创建一个部门表 employees.put(1001, new Employee(1001,&quot;AA&quot;,&quot;A13151@ew.com&quot;,0,new Department(101,&quot;教学部&quot;))); employees.put(1002, new Employee(1002,&quot;BB&quot;,&quot;B13151@ew.com&quot;,1,new Department(102,&quot;后勤部&quot;))); employees.put(1003, new Employee(1003,&quot;CC&quot;,&quot;C13151@ew.com&quot;,0,new Department(103,&quot;保卫部&quot;))); employees.put(1004, new Employee(1004,&quot;DD&quot;,&quot;D13151@ew.com&quot;,1,new Department(104,&quot;科研部&quot;))); employees.put(1005, new Employee(1005,&quot;EE&quot;,&quot;E13151@ew.com&quot;,0,new Department(105,&quot;学生部&quot;))); &#125; // 主键自增ID private static Integer initId = 1006; // 增加一个员工 public void save(Employee employee)&#123; if (employee.getId()==0)&#123; employee.setId(initId++); &#125; employee.setDepartment(departmentDao.getDepartment(employee.getDepartment().getId())); employees.put(employee.getId(),employee); &#125; // 查询全部员工 public Collection&lt;Employee&gt; getAll()&#123; return employees.values(); &#125; // 通过id查询员工 public Employee getById(Integer id)&#123; return employees.get(id); &#125; // 删除员工通过id public Employee removeById(Integer id)&#123; return employees.remove(id); &#125; &#125; DepartmentDao： package com.xiaoliu.dao; import com.xiaoliu.pojo.Department; import java.util.Collection; import java.util.HashMap; import java.util.Map; /** * @author: 61分 * @date: 2022/4/15 23:18 * @description: */ public class DepartmentDao &#123; // 模拟数据库中的数据 private static Map&lt;Integer, Department&gt; departments = null; static &#123; departments = new HashMap&lt;Integer, Department&gt;();//创建一个部门数据表 departments.put(101,new Department(101,&quot;教学部&quot;)); departments.put(102,new Department(102,&quot;后勤部&quot;)); departments.put(103,new Department(103,&quot;保卫部&quot;)); departments.put(104,new Department(104,&quot;科研部&quot;)); departments.put(105,new Department(105,&quot;学生部&quot;)); &#125; // 获得部门信息 public Collection&lt;Department&gt; getDepartments()&#123; return departments.values(); &#125; // 通过id得到部门 public Department getDepartment(Integer id)&#123; return departments.get(id); &#125; &#125;","categories":[],"tags":[]},{"title":"MVC配置原理及thymeleaf","slug":"4-15/thymeleaf语法","date":"2022-04-15T12:38:44.705Z","updated":"2022-04-15T15:59:59.772Z","comments":true,"path":"2022/04/15/4-15/thymeleaf语法/","link":"","permalink":"https://dddwah11.github.io/2022/04/15/4-15/thymeleaf%E8%AF%AD%E6%B3%95/","excerpt":"","text":"MVC配置原理如果想要div一些定制化的功能，只要写一个组件，然后将它交给springboot，springboot就会自动帮我们转配 package com.xiaoliu.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.View; import org.springframework.web.servlet.ViewResolver; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import java.util.Locale; /** * @author: 61分 * @date: 2022/4/15 21:17 * @description: */ //扩展 springmvc dispatcherservlet @Configuration public class MyMvcConfig implements WebMvcConfigurer &#123; @Bean public ViewResolver myViewResolver()&#123; return new myViewResolver(); &#125; // 自定义一个视图解析器 public static class myViewResolver implements ViewResolver &#123; @Override public View resolveViewName(String s, Locale locale) throws Exception &#123; return null; &#125; &#125; &#125; 基本的视图跳转 public class MyMvcConfig implements WebMvcConfigurer &#123; //视图跳转 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/xiaoliu&quot;).setViewName(&quot;index&quot;); &#125; &#125; 这样的话，视图跳转的文件，只能在templates， 而且thymeleaf也会失效 如果要扩展的话，官方建议这样去做 springboot中，xxxConfiguraion 可以实现很多扩展 thymeleafthymeleaf常用命名空间： xmlns:th&#x3D;”http://www.thymeleaf.org&quot;xmlns:sec&#x3D;”http://www.thymeleaf.org/extras/spring-security&quot;xmlns:shiro&#x3D;”http://www.pollix.at/thymeleaf/shiro&quot;","categories":[],"tags":[]},{"title":"SpringBoot Web开发","slug":"4-14/SpringBoot-Web开发","date":"2022-04-14T12:31:54.329Z","updated":"2022-04-14T14:35:21.083Z","comments":true,"path":"2022/04/14/4-14/SpringBoot-Web开发/","link":"","permalink":"https://dddwah11.github.io/2022/04/14/4-14/SpringBoot-Web%E5%BC%80%E5%8F%91/","excerpt":"","text":"jar:webpp! 导入静态资源 首页 jsp，模板引擎Thymeleaf 装配扩展SpringMVC 增删改查 拦截器 国际化 在springboot，我们使用以下方式处理静态资源 webjars localhost:8080/webjars/ public，static，&#x2F;**,resource localhost:8080/ 优先级 resource&gt;static(默认)&gt;public 首页如何定制index.html 最好设置在static里 在templates目录下的页面，只通过controller来跳转 需要模板引擎的支持","categories":[],"tags":[]},{"title":"自动装配原理","slug":"4-14/springboot主启动类运行","date":"2022-04-14T08:13:07.450Z","updated":"2022-04-15T11:45:51.337Z","comments":true,"path":"2022/04/14/4-14/springboot主启动类运行/","link":"","permalink":"https://dddwah11.github.io/2022/04/14/4-14/springboot%E4%B8%BB%E5%90%AF%E5%8A%A8%E7%B1%BB%E8%BF%90%E8%A1%8C/","excerpt":"","text":"主启动类运行 初始化 判断是不是为一个web应用 打开监听器全局处理上下文 通过主类加载，通过类加载获取spring。factories 装配环境参数 yaml 可以给实体类赋值 # k = v # 注入到我们配置类中 # 普通的key-value name : xiaoliu dog: name: xiaogou age: 3 # 对象 student: name: xiaoliu age: 3 ## 行内写法 student1: &#123;name: xialiu, age: 3&#125; ##数组 pets: - dog - vat - cat pets1: [dog,we,zw] ##对象 person: name: xiaoliu age: 3 happy: flase birth: 2022/10/2 map: &#123;k2: v1,k1: v2&#125; list: - code - music - book @ConfigurationProperties(prefix = &quot;person&quot;) 可以通过这个注解将配置文件中的值映射到组件 @component 上 也可以通过 @PropertySource(&quot;classpath:xiaoliu.properties&quot;) 注解映射到组件上 //加载指定的配置文件 @PropertySource(&quot;classpath:xiaoliu.properties&quot;) public class Person &#123; // SPEL表达式取值 @Value(&quot;$&#123;name&#125;&quot;) 松散绑定在yml中 写的为last-name 与lastName是一样的 jsr303校验约束注解名称 约束注解说明@Null 验证对象是否为空@NotNull 验证对象是否为非空@AssertTrue 验证 Boolean 对象是否为 true@AssertFalse 验证 Boolean 对象是否为 false@Min 验证 Number 和 String 对象是否大等于指定的值@Max 验证 Number 和 String 对象是否小等于指定的值@DecimalMin 验证 Number 和 String 对象是否大等于指定的值，小数存在精度@DecimalMax 验证 Number 和 String 对象是否小等于指定的值，小数存在精度@Size 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内@Digits 验证 Number 和 String 的构成是否合法@Past 验证 Date 和 Calendar 对象是否在当前时间之前@Future 验证 Date 和 Calendar 对象是否在当前时间之后@Pattern 验证 String 对象是否符合正则表达式的规则 自动配置原理xxxAutoConfiguration: 默认值 xxxproperties 和配置文件绑定 我们就可以使用自定义的配置 每一个 xxxAutoConfiguration 都是容器中的一个组件，最后都加入到容器中让他们自动配置 这就是自动装配的原理!精髓:1)、SpringBoot启动会加载大量的自动配置类2)、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中;3)、我们再来看这个自动配置类中到底配置了哪些组件; (只要我们要用的组件存在在其中，我们就不需要再手动配置了)4)、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可;xxxxAutoConfigurartion:自动配置类;给容器中添加组件xxxxProperties:封装配置文件中相关属性文件","categories":[],"tags":[]},{"title":"每日算法-quicksort","slug":"2022-4-13/每日算法-quicksort","date":"2022-04-13T15:47:43.908Z","updated":"2022-04-14T02:25:40.470Z","comments":true,"path":"2022/04/13/2022-4-13/每日算法-quicksort/","link":"","permalink":"https://dddwah11.github.io/2022/04/13/2022-4-13/%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95-quicksort/","excerpt":"","text":"有没有既不浪费空间又可以快一点的排序算法呢？那就是快速排啦！ /** * @author: 61分 * @date: 2022/4/14 0:05 * @description: */ public class quickSort &#123; public static void quickSort(int [] arr,int low,int high)&#123; int i,j,tmp,t; if (low&gt;high)&#123; return; &#125; i = low; j = high; tmp = arr[low]; while (i&lt;j)&#123; // 先看右边,从最右边递减 while (tmp&lt;=arr[j]&amp;&amp;i&lt;j)&#123; j--; &#125; // 再看左边，递加 while (tmp&gt;=arr[i]&amp;&amp;i&lt;j)&#123; i++; &#125; // 满足条件的话，交换他们的值 if (i&lt;j)&#123; t = arr[j]; arr[j] = arr[i]; arr[i] = t; &#125; &#125; arr[low] = arr[i]; arr[i] = tmp; // 之后递归调用 处理左边的 quickSort(arr,low,j-1); // 处理右边的 quickSort(arr,j+1,high); &#125; public static void main(String[] args) &#123; int [] num= &#123;10,54,21,42,78,65,48&#125;; quickSort(num,0,num.length-1); for (int i = 0; i &lt; num.length; i++) &#123; System.out.println(num[i]); &#125; &#125; &#125;","categories":[],"tags":[]},{"title":"spirngboot初学","slug":"2022-4-13/springboot","date":"2022-04-13T14:47:41.164Z","updated":"2022-04-14T02:25:29.426Z","comments":true,"path":"2022/04/13/2022-4-13/springboot/","link":"","permalink":"https://dddwah11.github.io/2022/04/13/2022-4-13/springboot/","excerpt":"","text":"SpringBoot原理1、自动装配原理pom.xml spring-boot-dependencies:核心依赖在父工程中 我们在引入一些spring依赖的时候，不需要指定版本，因为有这些版本仓库 启动器 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 是springboot的启动场景 比如springbootwb 就帮我们自动导入web环境所需的所有依赖！ 将所有的功能场景变成一个个启动器 springboot主程序 @SpringBootApplication public class HelloWorldApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloWorldApplication.class, args); &#125; &#125; 注解 @SpringBootConfiguration @SpringBootConfiguration 自动配置的核心文件 WEB-INF/spring.factories 所有的资源加载到配置类中 Properties properties = PropertiesLoaderUtils.loadProperties(resource) 核心注解 @ConditionalOnXXX 在满足所有条件才会生效 springboot自动配置都在启动的时候扫描并加载 spirng.properties 所有的自动配置类都在这个配置文件中，通过判断核心注解是否满足条件才能生效 springboot在启动的时候，通过类路径下的 WEB-INF/spirng.properties 获得指定的值 将这些自动配置的类导入容器，自动配置就会生效 即完成自动配置 整合javaEE 解决方案和自动配置的东西都在 spring-boot-test-autoconfigure-2.3.7.RELEASE.jar 中","categories":[],"tags":[]},{"title":"Mybatis-03","slug":"2022-4-13/Mybatis-03","date":"2022-04-13T02:48:32.989Z","updated":"2022-04-14T02:28:18.256Z","comments":true,"path":"2022/04/13/2022-4-13/Mybatis-03/","link":"","permalink":"https://dddwah11.github.io/2022/04/13/2022-4-13/Mybatis-03/","excerpt":"","text":"Mybatis-03设置（settings）这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项设置的含义、默认值等。 设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 true | false false aggressiveLazyLoading 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 lazyLoadTriggerMethods)。 true | false false （在 3.4.1 及之前的版本中默认为 true） multipleResultSetsEnabled 是否允许单个语句返回多结果集（需要数据库驱动支持）。 true | false true useColumnLabel 使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。 true | false true useGeneratedKeys 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。 true | false False autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 NONE, PARTIAL, FULL PARTIAL autoMappingUnknownColumnBehavior 指定发现自动映射目标未知列（或未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出警告日志（&#39;org.apache.ibatis.session.AutoMappingUnknownColumnBehavior&#39; 的日志等级必须设置为 WARN）FAILING: 映射失败 (抛出 SqlSessionException) NONE, WARNING, FAILING NONE defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。 SIMPLE REUSE BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定数据库驱动等待数据库响应的秒数。 任意正整数 未设置 (null) defaultFetchSize 为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。 任意正整数 未设置 (null) defaultResultSetType 指定语句默认的滚动策略。（新增于 3.5.2） FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT（等同于未设置） 未设置 (null) safeRowBoundsEnabled 是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 true | false False safeResultHandlerEnabled 是否允许在嵌套语句中使用结果处理器（ResultHandler）。如果允许使用则设置为 false。 true | false True mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 true | false False localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。 SESSION | STATEMENT SESSION jdbcTypeForNull 当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。 某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 JdbcType 常量，常用值：NULL、VARCHAR 或 OTHER。 OTHER lazyLoadTriggerMethods 指定对象的哪些方法触发一次延迟加载。 用逗号分隔的方法列表。 equals,clone,hashCode,toString defaultScriptingLanguage 指定动态 SQL 生成使用的默认脚本语言。 一个类型别名或全限定类名。 org.apache.ibatis.scripting.xmltags.XMLLanguageDriver defaultEnumTypeHandler 指定 Enum 使用的默认 TypeHandler 。（新增于 3.4.5） 一个类型别名或全限定类名。 org.apache.ibatis.type.EnumTypeHandler callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。 true | false false returnInstanceForEmptyRow 当返回行的所有列都是空时，MyBatis默认返回 null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2） true | false false logPrefix 指定 MyBatis 增加到日志名称的前缀。 任何字符串 未设置 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 proxyFactory 指定 Mybatis 创建可延迟加载对象所用到的代理工具。 CGLIB | JAVASSIST JAVASSIST （MyBatis 3.3 以上） vfsImpl 指定 VFS 的实现 自定义 VFS 的实现的类全限定名，以逗号分隔。 未设置 useActualParamName 允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 -parameters 选项。（新增于 3.4.1） true | false true configurationFactory 指定一个提供 Configuration 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为static Configuration getConfiguration() 的方法。（新增于 3.2.3） 一个类型别名或完全限定类名。 未设置 一个配置完整的 settings 元素的示例如下： &lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt; &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt; &lt;/settings&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; STDOUT_LOGGING标准日志输出：Logging initialized using ‘class org.apache.ibatis.logging.stdout.StdOutImpl’ adapter.PooledDataSource forcefully closed&#x2F;removed all connections.PooledDataSource forcefully closed&#x2F;removed all connections.PooledDataSource forcefully closed&#x2F;removed all connections.PooledDataSource forcefully closed&#x2F;removed all connections.Opening JDBC ConnectionCreated connection 775386112.Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2e377400]&#x3D;&#x3D;&gt; Preparing: select id,name,password from mybatis.user where id &#x3D; ?&#x3D;&#x3D;&gt; Parameters: 2(Integer)&lt;&#x3D;&#x3D; Columns: id, name, password&lt;&#x3D;&#x3D; Row: 2, 大刘哥, 1234&lt;&#x3D;&#x3D; Total: 1User{id&#x3D;2, name&#x3D;’大刘哥’, pwd&#x3D;’1234’}Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2e377400]Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2e377400]Returned connection 775386112 to pool. Process finished with exit code 0 Log4j 控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等； 我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 ​ 导入相关依赖 log4j.properties #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/xiaoliu.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 配置文件的实现： &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; &lt;/settings&gt; D:\\Java\\jdk1.8.0_191\\bin\\java.exe -ea -Didea.test.cyclic.buffer.size&#x3D;1048576 “-javaagent:D:\\IntelliJ?org.apache.ibatis.transaction.jdbc.JdbcTransaction?-Opening JDBC Connection?org.apache.ibatis.datasource.pooled.PooledDataSource?-Created connection 1151844284.?org.apache.ibatis.transaction.jdbc.JdbcTransaction?-Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@44a7bfbc]?com.xiaoliu.Dao.UserMapper.getUserById?-&#x3D;&#x3D;&gt; Preparing: select id,name,password from mybatis.user where id &#x3D; ??com.xiaoliu.Dao.UserMapper.getUserById?-&#x3D;&#x3D;&gt; Parameters: 2(Integer)?com.xiaoliu.Dao.UserMapper.getUserById?-&lt;&#x3D;&#x3D; Total: 1User{id&#x3D;2, name&#x3D;’大刘哥’, pwd&#x3D;’1234’}?org.apache.ibatis.transaction.jdbc.JdbcTransaction?-Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@44a7bfbc]?org.apache.ibatis.transaction.jdbc.JdbcTransaction?-Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@44a7bfbc]?org.apache.ibatis.datasource.pooled.PooledDataSource?-Returned connection 1151844284 to pool. Process finished with exit code 0 在使用时要记得到入包 import org.apache.log4j.Logger; 并在要使用的类下面使用当前的class static Logger logger = Logger.getLogger(UserMapperTest.class); 分页","categories":[],"tags":[]},{"title":"每日算法","slug":"2022-4-12/---","date":"2022-04-12T16:33:51.713Z","updated":"2022-04-13T02:34:51.169Z","comments":true,"path":"2022/04/13/2022-4-12/---/","link":"","permalink":"https://dddwah11.github.io/2022/04/13/2022-4-12/---/","excerpt":"","text":"/** * @author: 61分 * @date: 2022/4/13 0:23 * @description: */ public class popSort &#123; public static void main(String[] args) &#123; int[] nums=&#123;1,2,3,4,5,6,89,77&#125;; int tmp = 0; for (int i = 0; i &lt; nums.length-1; i++) &#123; for (int j = 0; j &lt; nums.length-i-1; j++) &#123; if (nums[j]&lt;nums[j+1])&#123; tmp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = tmp; &#125; &#125; &#125; for (int k = 0; k &lt; nums.length; k++) &#123; System.out.println(nums[k]); &#125; &#125; &#125;","categories":[],"tags":[]},{"title":"Mybatis02","slug":"2022-4-12/接口必须和Mapper配置文件同名接口必须和Mapper配置文件在同一个包下","date":"2022-04-12T12:09:05.748Z","updated":"2022-04-13T06:25:59.754Z","comments":true,"path":"2022/04/12/2022-4-12/接口必须和Mapper配置文件同名接口必须和Mapper配置文件在同一个包下/","link":"","permalink":"https://dddwah11.github.io/2022/04/12/2022-4-12/%E6%8E%A5%E5%8F%A3%E5%BF%85%E9%A1%BB%E5%92%8CMapper%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%8C%E5%90%8D%E6%8E%A5%E5%8F%A3%E5%BF%85%E9%A1%BB%E5%92%8CMapper%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8C%85%E4%B8%8B/","excerpt":"","text":"映射器 接口必须和Mapper配置文件同名 接口必须和Mapper配置文件在同一个包下 生命周期及其作用域 生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。 属性名和字段名的不一致 利用resultMap（结果集映射） UserMapper.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.xiaoliu.Dao.UserMapper&quot;&gt; &lt;!-- 结果集映射--&gt; &lt;!-- column为数据库中的字段名，property为实体类中的属性--&gt; &lt;resultMap id=&quot;UserMap&quot; type=&quot;com.xiaoliu.pojo.User&quot;&gt; &lt;!-- &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;--&gt; &lt;!-- &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;--&gt; &lt;result property=&quot;pwd&quot; column=&quot;password&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot;&gt; select id,name,password from mybatis.user where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 测试类： public class UserMapperTest &#123; @Test public void getUserById()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); // 获取接口 UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(2); System.out.println(user); sqlSession.close(); &#125; &#125; 结果： User{id&#x3D;2, name&#x3D;’大刘哥’, pwd&#x3D;’1234’} Process finished with exit code 0","categories":[],"tags":[]},{"title":"Mybatis初学","slug":"2022-4-11/Mybatis","date":"2022-04-11T14:31:27.955Z","updated":"2022-04-12T06:43:05.888Z","comments":true,"path":"2022/04/11/2022-4-11/Mybatis/","link":"","permalink":"https://dddwah11.github.io/2022/04/11/2022-4-11/Mybatis/","excerpt":"","text":"Mybatis1、什么是Mybatis​ MyBatis本是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了[google code](https://baike.baidu.com/item/google code&#x2F;2346604)，并且改名为MyBatis。2013年11月迁移到Github。 ​ iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs）。 ​ 当前，最新版本是MyBatis 3.5.9，其发布时间是2021年12月26日。 2、持久化​ 持久化是将程序数据在持久状态和瞬时状态间转换的机制。通俗的讲，就是瞬时数据（比如内存中的数据，是不能永久保存的）持久化为持久数据（比如持久化至数据库中，能够长久保存）。 3、持久层​ 可以理解成数据 保存在 数据库或者 硬盘一类可以保存很长时间的设备里面，不像放在内存中那样断电就消失了，也就是把数据存在持久化设备上，mybatis就是持久层。 内存：断点即失 4、Maven项目下创建第一个mybatis程序4.1 导入依赖：mysql驱动、mybatis、lombok。注意：maven资源导出问题：最好，父类，子类都添加&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 搭好项目结构： 4.3、去mybatis中文文档 粘贴需要用到的核心配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?userSSL=true&amp;amp;userUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 注册Mapper--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/xiaoliu/Mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 注意：注册mapper 4.4、编写实体类Userpackage com.xiaoliu.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /** * @author: 61分 * @date: 2022/4/11 17:35 * @description: */ @Data @NoArgsConstructor @AllArgsConstructor public class User &#123; private int id; private String name; private String password; &#125; 4.5、编写Mapper接口及实现的配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!--namespace=绑定对应的Mapper接口--&gt; &lt;mapper namespace=&quot;com.xiaoliu.Mapper.UserMapper&quot;&gt; &lt;!-- id对应的是方法名称--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.xiaoliu.pojo.User&quot;&gt; select * from mybatis.user &lt;/select&gt; &lt;/mapper&gt; 配置文件 UserMappe接口 package com.xiaoliu.Mapper; import com.xiaoliu.pojo.User; import java.util.List; /** * @author: 61分 * @date: 2022/4/11 17:41 * @description: */ public interface UserMapper &#123; List&lt;User&gt; getUserList(); &#125; ​ 4.6、编写MybatisUtil类获取SQLSession 执行SQLSession package com.xiaoliu.utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; /** * @author: 61分 * @date: 2022/4/11 15:55 * @description:获取SQLSessionFactory */ public class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; // 获取SQLSessionFactory-》SQLSession String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 // 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。 public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125; &#125; 4.7、编写Test类进行测试package com.xiaoliu.Mapper; import com.xiaoliu.pojo.User; import com.xiaoliu.utils.MybatisUtils; import org.apache.ibatis.session.SqlSession; import org.junit.Test; import java.util.List; /** * @author: 61分 * @date: 2022/4/11 18:00 * @description: */ public class UserMapperTest &#123; @Test public void test()&#123; // 第一步：获得sqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); System.out.println(&quot;getsqlSession&quot;); // 第二步，方式一：getMapper UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.getUserList(); System.out.println(&quot;getMapper&quot;); for (User user : userList) &#123; System.out.println(user); &#125; // 关闭sqlSession System.out.println(&quot;close&quot;); sqlSession.close(); &#125; &#125; 测试成功： 5、学习总结​ 注意注册Mapper，及maven资源导出的问题","categories":[],"tags":[]},{"title":"这是个测试块","slug":"we","date":"2022-03-22T12:51:06.905Z","updated":"2022-04-13T02:33:54.749Z","comments":true,"path":"2022/03/22/we/","link":"","permalink":"https://dddwah11.github.io/2022/03/22/we/","excerpt":"","text":"这是个测试块","categories":[],"tags":[]},{"title":"欢迎来到小刘的博客","slug":"hello-world","date":"2022-03-21T10:01:26.447Z","updated":"2022-03-22T12:50:21.804Z","comments":true,"path":"2022/03/21/hello-world/","link":"","permalink":"https://dddwah11.github.io/2022/03/21/hello-world/","excerpt":"","text":"暂时不知道写点啥","categories":[],"tags":[]}],"categories":[],"tags":[]}